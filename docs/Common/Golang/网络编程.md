# ç½‘ç»œç¼–ç¨‹

## Web æœåŠ¡å™¨

[åŒ… http](http://golang.org/pkg/net/http/) é€šè¿‡ä»»ä½•å®ç°äº† `http.Handler` çš„å€¼æ¥å“åº” HTTP è¯·æ±‚ï¼š

```go
package http

type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}
```

ä¸¾ä¸ªğŸŒ°ï¼Œä»¥ä¸‹ä»£ç ä¸­ï¼Œç±»å‹ `Hello` å®ç°äº† `http.Handler`ã€‚

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

type Hello struct{}

func (h Hello) ServeHTTP(
	w http.ResponseWriter,
	r *http.Request) {
	fmt.Fprint(w, "Hello!")
}

func main() {
	var h Hello
	err := http.ListenAndServe("localhost:4000", h)
	if err != nil {
		log.Fatal(err)
	}
}
```

## IP ç±»å‹

IPç±»å‹çš„å®šä¹‰å¦‚ä¸‹ï¼š

```
type IP []byte
```

`ParseIP(s string) IP`å‡½æ•°ä¼šæŠŠä¸€ä¸ªIPv4æˆ–è€…IPv6çš„åœ°å€è½¬åŒ–æˆIPç±»å‹ã€‚

ä¸¾ä¸ªğŸŒ°ï¼š

```go
package main
import (
	"net"
	"os"
	"fmt"
)
func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s ip-addr\n", os.Args[0])
		os.Exit(1)
	}
	name := os.Args[1]
	addr := net.ParseIP(name)
	if addr == nil {
		fmt.Println("Invalid address")
	} else {
		fmt.Println("The address is ", addr.String())
	}
	os.Exit(0)
}
```

æ‰§è¡Œä¹‹åï¼Œè¾“å…¥ä¸€ä¸ªIPåœ°å€å°±ä¼šç»™å‡ºç›¸åº”çš„IPæ ¼å¼

## TCP Socket

`TCPConn`ç±»å‹ï¼Œæœ‰ä¸¤ä¸ªä¸»è¦çš„å‡½æ•°ï¼š

```
func (c *TCPConn) Write(b []byte) (int, error)
func (c *TCPConn) Read(b []byte) (int, error)
```

`TCPConn`å¯ä»¥ç”¨åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯æ¥è¯»å†™æ•°æ®ã€‚

`TCPAddr`ç±»å‹ï¼Œè¡¨ç¤ºä¸€ä¸ªTCPçš„åœ°å€ä¿¡æ¯ï¼Œä»–çš„å®šä¹‰å¦‚ä¸‹ï¼š

```go
type TCPAddr struct {
	IP IP
	Port int
	Zone string // IPv6 scoped addressing zone
}
```

é€šè¿‡`ResolveTCPAddr`è·å–ä¸€ä¸ª`TCPAddr`ï¼š

```
func ResolveTCPAddr(net, addr string) (*TCPAddr, os.Error)
```

- netå‚æ•°æ˜¯"tcp4"ã€"tcp6"ã€"tcp"ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œåˆ†åˆ«è¡¨ç¤ºTCP(IPv4-only), TCP(IPv6-only)æˆ–è€…TCP(IPv4, IPv6çš„ä»»æ„ä¸€ä¸ª)ã€‚
- addrè¡¨ç¤ºåŸŸåæˆ–è€…IPåœ°å€åŠå…¶ç«¯å£å·ï¼Œä¾‹å¦‚"[www.google.com:80](http://www.google.com/)" æˆ–è€…"127.0.0.1:22"ã€‚

## TCP client

Goè¯­è¨€ä¸­é€šè¿‡netåŒ…ä¸­çš„`DialTCP`å‡½æ•°æ¥å»ºç«‹ä¸€ä¸ªTCPè¿æ¥ï¼Œå¹¶è¿”å›ä¸€ä¸ª`TCPConn`ç±»å‹çš„å¯¹è±¡ï¼Œå½“è¿æ¥å»ºç«‹æ—¶æœåŠ¡å™¨ç«¯ä¹Ÿåˆ›å»ºä¸€ä¸ªåŒç±»å‹çš„å¯¹è±¡ï¼Œæ­¤æ—¶å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯é€šè¿‡å„è‡ªæ‹¥æœ‰çš„`TCPConn`å¯¹è±¡æ¥è¿›è¡Œæ•°æ®äº¤æ¢ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œå®¢æˆ·ç«¯é€šè¿‡`TCPConn`å¯¹è±¡å°†è¯·æ±‚ä¿¡æ¯å‘é€åˆ°æœåŠ¡å™¨ç«¯ï¼Œè¯»å–æœåŠ¡å™¨ç«¯å“åº”çš„ä¿¡æ¯ã€‚æœåŠ¡å™¨ç«¯è¯»å–å¹¶è§£ææ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œå¹¶è¿”å›åº”ç­”ä¿¡æ¯ï¼Œè¿™ä¸ªè¿æ¥åªæœ‰å½“ä»»ä¸€ç«¯å…³é—­äº†è¿æ¥ä¹‹åæ‰å¤±æ•ˆï¼Œä¸ç„¶è¿™è¿æ¥å¯ä»¥ä¸€ç›´åœ¨ä½¿ç”¨ã€‚

å»ºç«‹è¿æ¥çš„å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š

```go
func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)
```

- networkå‚æ•°æ˜¯"tcp4"ã€"tcp6"ã€"tcp"ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œåˆ†åˆ«è¡¨ç¤ºTCP(IPv4-only)ã€TCP(IPv6-only)æˆ–è€…TCP(IPv4,IPv6çš„ä»»æ„ä¸€ä¸ª)
- laddrè¡¨ç¤ºæœ¬æœºåœ°å€ï¼Œä¸€èˆ¬è®¾ç½®ä¸ºnil
- raddrè¡¨ç¤ºè¿œç¨‹çš„æœåŠ¡åœ°å€

ä¸¾ä¸ªğŸŒ°ï¼šæ¨¡æ‹Ÿä¸€ä¸ªåŸºäºHTTPåè®®çš„å®¢æˆ·ç«¯è¯·æ±‚å»è¿æ¥ä¸€ä¸ªWebæœåŠ¡ç«¯ã€‚æˆ‘ä»¬è¦å†™ä¸€ä¸ªç®€å•çš„httpè¯·æ±‚å¤´ï¼Œæ ¼å¼ç±»ä¼¼å¦‚ä¸‹ï¼š

```go
"HEAD / HTTP/1.0\r\n\r\n"
```

ä»æœåŠ¡ç«¯æ¥æ”¶åˆ°çš„å“åº”ä¿¡æ¯æ ¼å¼å¯èƒ½å¦‚ä¸‹ï¼š

```json
HTTP/1.0 200 OK
ETag: "-9985996"
Last-Modified: Thu, 25 Mar 2010 17:51:10 GMT
Content-Length: 18074
Connection: close
Date: Sat, 28 Aug 2010 00:43:48 GMT
Server: lighttpd/1.4.23
```

æˆ‘ä»¬çš„å®¢æˆ·ç«¯ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net"
	"os"
)

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s host:port ", os.Args[0])
		os.Exit(1)
	}
	service := os.Args[1]
	tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
	checkError(err)
	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	checkError(err)
	_, err = conn.Write([]byte("HEAD / HTTP/1.0\r\n\r\n"))
	checkError(err)
	// result, err := ioutil.ReadAll(conn)
	result := make([]byte, 256)
	_, err = conn.Read(result)
	checkError(err)
	fmt.Println(string(result))
	os.Exit(0)
}
func checkError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error: %s", err.Error())
		os.Exit(1)
	}
}
```

é€šè¿‡ä¸Šé¢çš„ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼šé¦–å…ˆç¨‹åºå°†ç”¨æˆ·çš„è¾“å…¥ä½œä¸ºå‚æ•°`service`ä¼ å…¥`net.ResolveTCPAddr`è·å–ä¸€ä¸ªtcpAddr,ç„¶åæŠŠtcpAddrä¼ å…¥DialTCPååˆ›å»ºäº†ä¸€ä¸ªTCPè¿æ¥`conn`ï¼Œé€šè¿‡`conn`æ¥å‘é€è¯·æ±‚ä¿¡æ¯ï¼Œæœ€åé€šè¿‡`ioutil.ReadAll`ä»`conn`ä¸­è¯»å–å…¨éƒ¨çš„æ–‡æœ¬ï¼Œä¹Ÿå°±æ˜¯æœåŠ¡ç«¯å“åº”åé¦ˆçš„ä¿¡æ¯ã€‚

## TCP server

åœ¨æœåŠ¡å™¨ç«¯æˆ‘ä»¬éœ€è¦ç»‘å®šæœåŠ¡åˆ°æŒ‡å®šçš„éæ¿€æ´»ç«¯å£ï¼Œå¹¶ç›‘å¬æ­¤ç«¯å£ï¼Œå½“æœ‰å®¢æˆ·ç«¯è¯·æ±‚åˆ°è¾¾çš„æ—¶å€™å¯ä»¥æ¥æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯è¿æ¥çš„è¯·æ±‚ã€‚

netåŒ…ä¸­æœ‰ç›¸åº”åŠŸèƒ½çš„å‡½æ•°ï¼Œå‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š

```
func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)
func (l *TCPListener) Accept() (Conn, error)
```

å‚æ•°è¯´æ˜åŒDialTCPçš„å‚æ•°ä¸€æ ·ã€‚

ä¸¾ä¸ªğŸŒ°ï¼š

æˆ‘ä»¬å®ç°ä¸€ä¸ªç®€å•çš„æ—¶é—´åŒæ­¥æœåŠ¡ï¼Œç›‘å¬7777ç«¯å£ï¼Œå½“æœ‰æ–°çš„å®¢æˆ·ç«¯è¯·æ±‚åˆ°è¾¾å¹¶åŒæ„æ¥å—`Accept`è¯¥è¯·æ±‚çš„æ—¶å€™ä»–ä¼šåé¦ˆå½“å‰çš„æ—¶é—´ä¿¡æ¯ã€‚åœ¨ä»£ç ä¸­`for`å¾ªç¯é‡Œï¼Œå½“æœ‰é”™è¯¯å‘ç”Ÿæ—¶ï¼Œç›´æ¥continueè€Œä¸æ˜¯é€€å‡ºï¼Œæ˜¯å› ä¸ºåœ¨æœåŠ¡å™¨ç«¯è·‘ä»£ç çš„æ—¶å€™ï¼Œå½“æœ‰é”™è¯¯å‘ç”Ÿçš„æƒ…å†µä¸‹æœ€å¥½æ˜¯ç”±æœåŠ¡ç«¯è®°å½•é”™è¯¯ï¼Œç„¶åå½“å‰è¿æ¥çš„å®¢æˆ·ç«¯ç›´æ¥æŠ¥é”™è€Œé€€å‡ºï¼Œä»è€Œä¸ä¼šå½±å“åˆ°å½“å‰æœåŠ¡ç«¯è¿è¡Œçš„æ•´ä¸ªæœåŠ¡ã€‚

```go
package main

import (
	"fmt"
	"net"
	"os"
	"time"
	"strconv"
	"strings"
)

func main() {
	service := ":1200"
	tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
	checkError(err)
	listener, err := net.ListenTCP("tcp", tcpAddr)
	checkError(err)
	for {
		conn, err := listener.Accept()
		if err != nil {
			continue
		}
		go handleClient(conn) // å®ç°å¹¶å‘
	}
}

// æŠŠä¸šåŠ¡å¤„ç†åˆ†ç¦»åˆ°å‡½æ•° handleClient
func handleClient(conn net.Conn) {
	conn.SetReadDeadline(time.Now().Add(2 * time.Minute)) // set 2 minutes timeout
	request := make([]byte, 128) // set maxium request length to 128B to prevent flood attack
	defer conn.Close()  // close connection before exit
	for {
		read_len, err := conn.Read(request)

		if err != nil {
			fmt.Println(err)
			break
		}

    		if read_len == 0 {
    			break // connection already closed by client
    		} else if strings.TrimSpace(string(request[:read_len])) == "timestamp" {
    			daytime := strconv.FormatInt(time.Now().Unix(), 10)
    			conn.Write([]byte(daytime))
    		} else {
    			daytime := time.Now().String()
    			conn.Write([]byte(daytime))
    		}

    		request = make([]byte, 128) // clear last read content
	}
}

func checkError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error: %s", err.Error())
		os.Exit(1)
	}
}
```

åœ¨ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨`conn.Read()`ä¸æ–­è¯»å–å®¢æˆ·ç«¯å‘æ¥çš„è¯·æ±‚ã€‚ç”±äºæˆ‘ä»¬éœ€è¦ä¿æŒä¸å®¢æˆ·ç«¯çš„é•¿è¿æ¥ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨è¯»å–å®Œä¸€æ¬¡è¯·æ±‚åå°±å…³é—­è¿æ¥ã€‚ç”±äº`conn.SetReadDeadline()`è®¾ç½®äº†è¶…æ—¶ï¼Œå½“ä¸€å®šæ—¶é—´å†…å®¢æˆ·ç«¯æ— è¯·æ±‚å‘é€ï¼Œ`conn`ä¾¿ä¼šè‡ªåŠ¨å…³é—­ï¼Œä¸‹é¢çš„forå¾ªç¯å³ä¼šå› ä¸ºè¿æ¥å·²å…³é—­è€Œè·³å‡ºã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`request`åœ¨åˆ›å»ºæ—¶éœ€è¦æŒ‡å®šä¸€ä¸ªæœ€å¤§é•¿åº¦ä»¥é˜²æ­¢flood attackï¼›æ¯æ¬¡è¯»å–åˆ°è¯·æ±‚å¤„ç†å®Œæ¯•åï¼Œéœ€è¦æ¸…ç†requestï¼Œå› ä¸º`conn.Read()`ä¼šå°†æ–°è¯»å–åˆ°çš„å†…å®¹appendåˆ°åŸå†…å®¹ä¹‹åã€‚

## æ§åˆ¶TCPè¿æ¥

```go
func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)  // è®¾ç½®å»ºç«‹è¿æ¥çš„è¶…æ—¶æ—¶é—´
```

```go
func (c *TCPConn) SetReadDeadline(t time.Time) error  // è®¾ç½®è¯»å–ä¸€ä¸ªè¿æ¥çš„è¶…æ—¶æ—¶é—´
func (c *TCPConn) SetWriteDeadline(t time.Time) error  // è®¾ç½®å†™å…¥ä¸€ä¸ªè¿æ¥çš„è¶…æ—¶æ—¶é—´
```

```go
func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error  // è®¾ç½®keepAliveå±æ€§
```

## UDP Socket

Goè¯­è¨€åŒ…ä¸­å¤„ç†UDP Socketå’ŒTCP Socketä¸åŒçš„åœ°æ–¹å°±æ˜¯åœ¨æœåŠ¡å™¨ç«¯å¤„ç†å¤šä¸ªå®¢æˆ·ç«¯è¯·æ±‚æ•°æ®åŒ…çš„æ–¹å¼ä¸åŒ,UDPç¼ºå°‘äº†å¯¹å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚çš„Acceptå‡½æ•°ã€‚

```go
func ResolveUDPAddr(net, addr string) (*UDPAddr, os.Error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error)
func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error)
func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error)
func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error)
```

ä¸¾ä¸ªğŸŒ°

UDPçš„å®¢æˆ·ç«¯ï¼šï¼ˆTCPæ¢æˆäº†UDPè€Œå·²ï¼‰

```go
package main

import (
	"fmt"
	"net"
	"os"
)

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s host:port", os.Args[0])
		os.Exit(1)
	}
	service := os.Args[1]
	udpAddr, err := net.ResolveUDPAddr("udp4", service)
	checkError(err)
	conn, err := net.DialUDP("udp", nil, udpAddr)
	checkError(err)
	_, err = conn.Write([]byte("anything"))
	checkError(err)
	var buf [512]byte
	n, err := conn.Read(buf[0:])
	checkError(err)
	fmt.Println(string(buf[0:n]))
	os.Exit(0)
}
func checkError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error %s", err.Error())
		os.Exit(1)
	}
}
```

ç›¸åº”çš„UDPæœåŠ¡å™¨ç«¯ï¼š

```go
package main

import (
	"fmt"
	"net"
	"os"
	"time"
)

func main() {
	service := ":1200"
	udpAddr, err := net.ResolveUDPAddr("udp4", service)
	checkError(err)
	conn, err := net.ListenUDP("udp", udpAddr)
	checkError(err)
	for {
		handleClient(conn)
	}
}
func handleClient(conn *net.UDPConn) {
	var buf [512]byte
	_, addr, err := conn.ReadFromUDP(buf[0:])
	if err != nil {
		return
	}
	daytime := time.Now().String()
	conn.WriteToUDP([]byte(daytime), addr)
}
func checkError(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error %s", err.Error())
		os.Exit(1)
	}
}
```

## WebSocket

WebSocket åˆ†ä¸ºå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯

WebSocket é‡‡ç”¨äº†ä¸€äº›ç‰¹æ®Šçš„æŠ¥å¤´ï¼Œä½¿å¾—æµè§ˆå™¨å’ŒæœåŠ¡å™¨åªéœ€è¦åšä¸€ä¸ªæ¡æ‰‹çš„åŠ¨ä½œï¼Œå°±å¯ä»¥åœ¨æµè§ˆå™¨å’ŒæœåŠ¡å™¨ä¹‹é—´å»ºç«‹ä¸€æ¡è¿æ¥é€šé“ã€‚ä¸”æ­¤è¿æ¥ä¼šä¿æŒåœ¨æ´»åŠ¨çŠ¶æ€ï¼Œä½ å¯ä»¥ä½¿ç”¨JavaScriptæ¥å‘è¿æ¥å†™å…¥æˆ–ä»ä¸­æ¥æ”¶æ•°æ®ï¼Œå°±åƒåœ¨ä½¿ç”¨ä¸€ä¸ªå¸¸è§„çš„TCP Socketä¸€æ ·ã€‚å®ƒè§£å†³äº†Webå®æ—¶åŒ–çš„é—®é¢˜ï¼Œç›¸æ¯”ä¼ ç»ŸHTTPæœ‰å¦‚ä¸‹å¥½å¤„ï¼š

- ä¸€ä¸ªWebå®¢æˆ·ç«¯åªå»ºç«‹ä¸€ä¸ªTCPè¿æ¥
- WebsocketæœåŠ¡ç«¯å¯ä»¥æ¨é€(push)æ•°æ®åˆ°webå®¢æˆ·ç«¯.
- æœ‰æ›´åŠ è½»é‡çº§çš„å¤´ï¼Œå‡å°‘æ•°æ®ä¼ é€é‡

WebSocket URLçš„èµ·å§‹è¾“å…¥æ˜¯ws://æˆ–æ˜¯wss://ï¼ˆåœ¨SSLä¸Šï¼‰ã€‚

Goè¯­è¨€æ ‡å‡†åŒ…é‡Œé¢æ²¡æœ‰æä¾›å¯¹WebSocketçš„æ”¯æŒï¼Œä½†æ˜¯åœ¨ç”±å®˜æ–¹ç»´æŠ¤çš„go.netå­åŒ…ä¸­æœ‰å¯¹è¿™ä¸ªçš„æ”¯æŒï¼Œå¯ä»¥é€šè¿‡å¦‚ä¸‹çš„å‘½ä»¤è·å–è¯¥åŒ…ï¼š

```go
go get golang.org/x/net/websocket
```

ä¸¾ä¸ªğŸŒ°: 

éœ€æ±‚ï¼šç”¨æˆ·è¾“å…¥ä¿¡æ¯ï¼Œå®¢æˆ·ç«¯é€šè¿‡WebSocketå°†ä¿¡æ¯å‘é€ç»™æœåŠ¡å™¨ç«¯ï¼ŒæœåŠ¡å™¨ç«¯æ”¶åˆ°ä¿¡æ¯ä¹‹åä¸»åŠ¨Pushä¿¡æ¯åˆ°å®¢æˆ·ç«¯ï¼Œç„¶åå®¢æˆ·ç«¯å°†è¾“å‡ºå…¶æ”¶åˆ°çš„ä¿¡æ¯ã€‚

å®¢æˆ·ç«¯çš„ä»£ç å¦‚ä¸‹ï¼š

```
<html>
<head></head>
<body>
	<script type="text/javascript">
		var sock = null;
		var wsuri = "ws://127.0.0.1:1234";

		window.onload = function() {

			console.log("onload");

			sock = new WebSocket(wsuri);

			sock.onopen = function() {
				console.log("connected to " + wsuri);
			}

			sock.onclose = function(e) {
				console.log("connection closed (" + e.code + ")");
			}

			sock.onmessage = function(e) {
				console.log("message received: " + e.data);
			}
		};

		function send() {
			var msg = document.getElementById('message').value;
			sock.send(msg);
		};
	</script>
	<h1>WebSocket Echo Test</h1>
	<form>
		<p>
			Message: <input id="message" type="text" value="Hello, world!">
		</p>
	</form>
	<button onclick="send();">Send Message</button>
</body>
</html>
```

å¯ä»¥çœ‹åˆ°å®¢æˆ·ç«¯JSï¼Œå¾ˆå®¹æ˜“çš„å°±é€šè¿‡WebSocketå‡½æ•°å»ºç«‹äº†ä¸€ä¸ªä¸æœåŠ¡å™¨çš„è¿æ¥sockï¼Œå½“æ¡æ‰‹æˆåŠŸåï¼Œä¼šè§¦å‘WebSocketå¯¹è±¡çš„onopenäº‹ä»¶ï¼Œå‘Šè¯‰å®¢æˆ·ç«¯è¿æ¥å·²ç»æˆåŠŸå»ºç«‹ã€‚å®¢æˆ·ç«¯ä¸€å…±ç»‘å®šäº†å››ä¸ªäº‹ä»¶ã€‚

- 1ï¼‰onopen å»ºç«‹è¿æ¥åè§¦å‘
- 2ï¼‰onmessage æ”¶åˆ°æ¶ˆæ¯åè§¦å‘
- 3ï¼‰onerror å‘ç”Ÿé”™è¯¯æ—¶è§¦å‘
- 4ï¼‰onclose å…³é—­è¿æ¥æ—¶è§¦å‘

æˆ‘ä»¬æœåŠ¡å™¨ç«¯çš„å®ç°å¦‚ä¸‹ï¼š

```
package main

import (
	"golang.org/x/net/websocket"
	"fmt"
	"log"
	"net/http"
)

func Echo(ws *websocket.Conn) {
	var err error

	for {
		var reply string

		if err = websocket.Message.Receive(ws, &reply); err != nil {
			fmt.Println("Can't receive")
			break
		}

		fmt.Println("Received back from client: " + reply)

		msg := "Received:  " + reply
		fmt.Println("Sending to client: " + msg)

		if err = websocket.Message.Send(ws, msg); err != nil {
			fmt.Println("Can't send")
			break
		}
	}
}

func main() {
	http.Handle("/", websocket.Handler(Echo))

	if err := http.ListenAndServe(":1234", nil); err != nil {
		log.Fatal("ListenAndServe:", err)
	}
}
```

å½“å®¢æˆ·ç«¯å°†ç”¨æˆ·è¾“å…¥çš„ä¿¡æ¯Sendä¹‹åï¼ŒæœåŠ¡å™¨ç«¯é€šè¿‡Receiveæ¥æ”¶åˆ°äº†ç›¸åº”ä¿¡æ¯ï¼Œç„¶åé€šè¿‡Sendå‘é€äº†åº”ç­”ä¿¡æ¯ã€‚

## REST

- HTMLæ ‡å‡†åªèƒ½é€šè¿‡é“¾æ¥å’Œè¡¨å•æ”¯æŒ`GET`å’Œ`POST`ã€‚åœ¨æ²¡æœ‰Ajaxæ”¯æŒçš„ç½‘é¡µæµè§ˆå™¨ä¸­ä¸èƒ½å‘å‡º`PUT`æˆ–`DELETE`å‘½ä»¤
- æœ‰äº›é˜²ç«å¢™ä¼šæŒ¡ä½HTTP `PUT`å’Œ`DELETE`è¯·æ±‚ï¼Œè¦ç»•è¿‡è¿™ä¸ªé™åˆ¶ï¼Œå®¢æˆ·ç«¯éœ€è¦æŠŠå®é™…çš„`PUT`å’Œ`DELETE`è¯·æ±‚é€šè¿‡ POST è¯·æ±‚ç©¿é€è¿‡æ¥ã€‚RESTful æœåŠ¡åˆ™è¦è´Ÿè´£åœ¨æ”¶åˆ°çš„ POST è¯·æ±‚ä¸­æ‰¾åˆ°åŸå§‹çš„ HTTP æ–¹æ³•å¹¶è¿˜åŸã€‚å¯ä»¥é€šè¿‡`POST`é‡Œé¢å¢åŠ éšè—å­—æ®µ`_method`è¿™ç§æ–¹å¼å¯ä»¥æ¥æ¨¡æ‹Ÿ`PUT`ã€`DELETE`ç­‰æ–¹å¼ï¼Œä½†æ˜¯æœåŠ¡å™¨ç«¯éœ€è¦åšè½¬æ¢ã€‚

ä¸¾ä¸ªğŸŒ°: 

éœ€æ±‚ï¼šæˆ‘ä»¬è®¿é—®çš„èµ„æºæ˜¯ç”¨æˆ·ï¼Œæˆ‘ä»¬é€šè¿‡ä¸åŒçš„methodæ¥è®¿é—®ä¸åŒçš„å‡½æ•°ã€‚

ç¬¬ä¸‰æ–¹åº“`github.com/julienschmidt/httprouter`ï¼Œè¿™ä¸ªåº“å®ç°äº†è‡ªå®šä¹‰è·¯ç”±å’Œæ–¹ä¾¿çš„è·¯ç”±è§„åˆ™æ˜ å°„ï¼Œé€šè¿‡å®ƒï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿çš„å®ç°RESTçš„æ¶æ„ã€‚

```go
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/julienschmidt/httprouter"
)

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	fmt.Fprint(w, "Welcome!\n")
}

func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	fmt.Fprintf(w, "hello, %s!\n", ps.ByName("name"))
}

func getuser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	uid := ps.ByName("uid")
	fmt.Fprintf(w, "you are get user %s", uid)
}

func modifyuser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	uid := ps.ByName("uid")
	fmt.Fprintf(w, "you are modify user %s", uid)
}

func deleteuser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	uid := ps.ByName("uid")
	fmt.Fprintf(w, "you are delete user %s", uid)
}

func adduser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	// uid := r.FormValue("uid")
	uid := ps.ByName("uid")
	fmt.Fprintf(w, "you are add user %s", uid)
}

func main() {
	router := httprouter.New()
	router.GET("/", Index)
	router.GET("/hello/:name", Hello)

	router.GET("/user/:uid", getuser)
	router.POST("/adduser/:uid", adduser)
	router.DELETE("/deluser/:uid", deleteuser)
	router.PUT("/moduser/:uid", modifyuser)

	log.Fatal(http.ListenAndServe(":8080", router))
}
```

é€šè¿‡ä¸Šé¢çš„ä»£ç å¯çŸ¥ï¼ŒRESTå°±æ˜¯æ ¹æ®ä¸åŒçš„methodè®¿é—®åŒä¸€ä¸ªèµ„æºçš„æ—¶å€™å®ç°ä¸åŒçš„é€»è¾‘å¤„ç†ã€‚